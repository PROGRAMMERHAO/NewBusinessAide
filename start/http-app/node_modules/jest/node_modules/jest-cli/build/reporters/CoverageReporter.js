'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}var _require =























require('jest-util');const clearLine = _require.clearLine; /**
                                                           * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                                                           *
                                                           * This source code is licensed under the BSD-style license found in the
                                                           * LICENSE file in the root directory of this source tree. An additional grant
                                                           * of patent rights can be found in the PATENTS file in the same directory.
                                                           *
                                                           * 
                                                           */var _require2 = require('istanbul-api');const createReporter = _require2.createReporter;const chalk = require('chalk');const isCI = require('is-ci');const istanbulCoverage = require('istanbul-lib-coverage');const libSourceMaps = require('istanbul-lib-source-maps');const pify = require('pify');const workerFarm = require('worker-farm');
const BaseReporter = require('./BaseReporter');

const FAIL_COLOR = chalk.bold.red;
const RUNNING_TEST_COLOR = chalk.bold.dim;

const isInteractive = process.stdout.isTTY && !isCI;

class CoverageReporter extends BaseReporter {





  constructor(globalConfig, options) {
    super(globalConfig);
    this._coverageMap = istanbulCoverage.createCoverageMap({});
    this._globalConfig = globalConfig;
    this._sourceMapStore = libSourceMaps.createSourceMapStore();
    this._maxWorkers = options.maxWorkers;
  }

  onTestResult(
  test,
  testResult,
  aggregatedResults)
  {
    if (testResult.coverage) {
      this._coverageMap.merge(testResult.coverage);
      // Remove coverage data to free up some memory.
      delete testResult.coverage;

      Object.keys(testResult.sourceMaps).forEach(sourcePath => {
        this._sourceMapStore.registerURL(
        sourcePath,
        testResult.sourceMaps[